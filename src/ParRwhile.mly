/* This ocamlyacc file was machine-generated by the BNF converter */
%{
open AbsRwhile
open Lexing


%}

%token TOK_cons TOK_do TOK_else TOK_fi TOK_from TOK_hd TOK_if TOK_loop TOK_macro TOK_nil TOK_read TOK_show TOK_then TOK_tl TOK_until TOK_write

%token SYMB1 /* ; */
%token SYMB2 /* ( */
%token SYMB3 /* ) */
%token SYMB4 /* , */
%token SYMB5 /* ^= */
%token SYMB6 /* <= */
%token SYMB7 /* =? */
%token SYMB8 /* . */

%token TOK_EOF
%token <string> TOK_Ident
%token <string> TOK_String
%token <int> TOK_Integer
%token <float> TOK_Double
%token <char> TOK_Char
%token <string> TOK_RIdent
%token <string> TOK_Atom

%start pProgram pValT
%type <AbsRwhile.program> pProgram
%type <AbsRwhile.valT> pValT


%%
pProgram : program TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pValT : valT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };


program : macro_list TOK_read rIdent SYMB1 com SYMB1 TOK_write rIdent { Prog ((List.rev $1), $3, $5, $8) } 
;

macro_list : /* empty */ { []  } 
  | macro_list macro { (fun (x,xs) -> x::xs) ($2, $1) }
;

macro : TOK_macro rIdent SYMB2 rIdent_list SYMB3 com { Mac ($2, $4, $6) } 
;

rIdent_list : /* empty */ { []  } 
  | rIdent { (fun x -> [x]) $1 }
  | rIdent SYMB4 rIdent_list { (fun (x,xs) -> x::xs) ($1, $3) }
;

com : com SYMB1 com1 { CSeq ($1, $3) } 
  | com1 {  $1 }
;

com1 : rIdent SYMB2 rIdent_list SYMB3 { CMac ($1, $3) } 
  | rIdent SYMB5 exp { CAss ($1, $3) }
  | pat SYMB6 pat { CRep ($1, $3) }
  | TOK_if exp thenBranch elseBranch TOK_fi exp { CCond ($2, $3, $4, $6) }
  | TOK_from exp doBranch loopBranch TOK_until exp { CLoop ($2, $3, $4, $6) }
  | TOK_show exp { CShow $2 }
  | SYMB2 com SYMB3 {  $2 }
;

thenBranch : TOK_then com { BThen $2 } 
  | /* empty */ { BThenNone  }
;

elseBranch : TOK_else com { BElse $2 } 
  | /* empty */ { BElseNone  }
;

doBranch : TOK_do com { BDo $2 } 
  | /* empty */ { BDoNone  }
;

loopBranch : TOK_loop com { BLoop $2 } 
  | /* empty */ { BLoopNone  }
;

exp : TOK_cons exp1 exp1 { ECons ($2, $3) } 
  | TOK_hd exp1 { EHd $2 }
  | TOK_tl exp1 { ETl $2 }
  | SYMB7 exp1 exp1 { EEq ($2, $3) }
  | exp1 {  $1 }
;

exp1 : variable { EVar $1 } 
  | valT { EVal $1 }
  | SYMB2 exp SYMB3 {  $2 }
;

pat : TOK_cons pat1 pat1 { PCons ($2, $3) } 
  | pat1 {  $1 }
;

pat1 : variable { PVar $1 } 
  | valT { PVal $1 }
  | SYMB2 pat SYMB3 {  $2 }
;

valT : TOK_nil { VNil  } 
  | atom { VAtom $1 }
  | SYMB2 valT SYMB8 valT SYMB3 { VCons ($2, $4) }
;

variable : rIdent { Var $1 } 
;


rIdent : TOK_RIdent { RIdent ($1)};
atom : TOK_Atom { Atom ($1)};


